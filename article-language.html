<!DOCTYPE html>
<html lang="en">

<head>
<!--__RIM_REDIRECT__-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">

<title>RimStone is a different kind of programming language</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="HandheldFriendly" content="True"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="canonical" href="https://rimstone-lang.com/article-language.html" />
<style>


body, html {
    font-family: Quicksand,monospace,Helvetica, Arial, sans-serif;
    line-height: 150%;
    font-size:16px;
}

body {
    padding-left:1vw;
    padding-right:1vw;
}
    
.ncode {
    letter-spacing: 0px;
    font-family: monospace;
    font-size:83%;
    display:inline-block;
    max-width:99%;
    min-width:90%;
    margin:0;
    padding:0;
    padding-left:5px;
    padding-top:3px;
    padding-bottom:3px;
    margin-bottom:8px;
    margin-top:8px;
    border: 2px solid #d6d6d6;
    background-color:#f5f7f4;
    white-space:nowrap;
}

.shcode {
    letter-spacing: 0px;
    font-family: monospace;
    font-size:83%;
    display:inline-block;
    max-width:99%;
    min-width:90%;
    margin:0;
    padding:0;
    padding-left:5px;
    padding-top:3px;
    padding-bottom:3px;
    margin-bottom:8px;
    margin-top:8px;
    border: 2px solid #d6d6d6;
    background-color:#f5f7f4;
    white-space:nowrap;
}

.sqlcode {
    letter-spacing: 0px;
    font-family: monospace;
    font-size:83%;
    display:inline-block;
    max-width:99%;
    min-width:90%;
    margin:0;
    padding:0;
    padding-left:5px;
    padding-top:3px;
    padding-bottom:3px;
    margin-bottom:8px;
    margin-top:8px;
    border: 2px solid #d6d6d6;
    background-color:#f5f7f4;
    white-space:nowrap;
}

.htmlcode {
    letter-spacing: 0px;
    font-family: monospace;
    font-size:83%;
    display:inline-block;
    max-width:99%;
    min-width:90%;
    margin:0;
    padding:0;
    padding-left:5px;
    padding-top:3px;
    padding-bottom:3px;
    margin-bottom:8px;
    margin-top:8px;
    border: 2px solid #d6d6d6;
    background-color:#f5f7f4;
    white-space:nowrap;
}

.code {
    letter-spacing: 0px;
    font-family: monospace;
    font-size:83%;
    display:inline-block;
    max-width:99%;
    min-width:90%;
    margin:0;
    padding:0;
    padding-left:5px;
    padding-top:3px;
    padding-bottom:3px;
    margin-bottom:8px;
    margin-top:8px;
    border: 2px solid #d6d6d6;
    background-color:#f5f7f4;
    white-space:nowrap;
}

/*Just like h1 but for pdf conversion it would be indented this way it's not*/
.vhub {
    display: block;
   font-size: 1.6em;
   margin-top: 0.63em;
   margin-bottom: 0.63em;
   margin-left: 0;
   margin-right: 0;
   font-weight: bold;
}

/*Just like h2 but for pdf conversion it would be indented this way it's not*/
.vsub {
    display: block;
   font-size: 1.25em;
   margin-top: 0.53em;
   margin-bottom: 0.53em;
   margin-left: 0;
   margin-right: 0;
   font-weight: bold;
}

ul {
  margin-left: 0.75vw;
  padding-left: 0;
}
li {
  margin-left: 0.75vw;
  padding-left: 0;
}

/* this must be last, as it overrides previous settings, for mobile */
@media (hover: none) {
a {
   display: inline-block;
   padding-top: 3px;
   padding-bottom: 2px;
}
body {
    padding-left:2vw;
    padding-right:2vw;
    letter-spacing: 1px;
}
}

/*The following is for code snippets that are highlighted by 2html vim*/
pre { overflow-x: scroll; margin:0; padding:0; font-family:monospace; }
.Identifier { color: #008b8b; }
.Statement { color: #af5f00; }
.PreProc { color: #5fd7ff; }
.Type { color: #005f00; }
.Comment { color: blue ; }
.Constant { color: #ff00ff; }
/*end of highlighted snippets*/

a {
    text-decoration:none;
    padding-bottom: 0px; 
    color:inherit;
    border-bottom: 2px solid #6cb8f0;
}
a:hover {
    text-decoration: none;
    color:black;
    border-bottom: 1px solid red;
}
/*do not underline links nor should they be active*/
pre a {
    text-decoration:none;
    color:black;
    border-bottom: none;
    pointer-events: none;
    cursor: default;
}


.golfSnippet {display:none;}

ul {
  list-style-type:square;
  list-style-position: outside;
}

</style>


</head>
<body>
<div id="google_translate_element" style='float:right'></div>
<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
<script>
function rim_copy(gt, eid, gc) {
  gt.textContent = eid.textContent;
  gt.select();
  document.execCommand("copy");
  gc.style.visibility="visible"
  setTimeout(()=>{ gc.style.visibility="hidden"; }, 1000);
}
function googleTranslateElementInit() {
   new google.translate.TranslateElement({pageLanguage: 'en'}, 'google_translate_element');
}

</script>

<!--RIMMENU13-->

<!--RIMENDMENU13-->



<!--BEGVDOC90-->
<div class='vhub' style='margin-top:10px;margin-right:20px;text-align:left;background-color:white;'><a href='https://rimstone-lang.com' style='border-bottom:0px'><img src='https://rimstone-lang.com/rimstone.png' style='width:180px;height:auto'/></a></div><div class='vhub' style='margin-top:10px;'>RimStone is a different kind of programming language</div><hr/><br/>
<div class="vsub"><a id="From a bicycle to a rocket"></a>From a bicycle to a rocket</div>
Over the past 50 years, many general-purpose programming languages became more complex due to the constant influx of new features (some of which are great, while others are a "feature creep"). Just look at some major programming languages in their early days, versus the latest incarnations. From a distance, it may look like you switched from riding a bicycle to flying a passenger jet with a few hundred knobs, buttons and readout consoles. Arguably, the language structure covers many more usage patterns, yields additional power, and safety has improved, but the complexity and the learning curve has increased too. While in the beginning there was lots of pitfalls due to the lack of features and safety, in the end there's a minefield due to an overcrowded feature-scape that's paralyzing to deal with and often not quite understood by anyone on the team.<br/>
<div class="vsub"><a id="Cryptic feel and complexity"></a>Cryptic feel and complexity</div>
If you look at a moderately involved application these days, you can intuitively experience this without any need for a formal explanation. This is true especially if you are not familiar with the language involved. The level of "cryptic" in programming languages has gone up notches.<br/>
<br/>
When writing software, useful complexity helps by providing structure as well as the shortest path to actualizing an algorithm. "Useful" complexity stands in contrast to complexity that doesn't yield enough benefits to justify itself. Typically, the useful kind is the ability to quickly make workable programs, the power of its constructs, memory safety, performance etc. Often a given benefit compromises another, i.e. you "can't have it all". This is where the perceived benefits become more personal and vary based on where exactly the emphasis is.<br/>
<div class="vsub"><a id="Abstraction"></a>Abstraction</div>
Abstraction is good in moderation, much like anything else. It's good we're not programming in assembler anymore. Concepts like encapsulation and code reuse are great. Somewhere along the line though things got a bit wild. Don't ask me where, because it probably depends on your capacity for layering concepts on top of each other and mentally imaging the inner workings with all of its nuts and bolts. But somewhere along the line abstraction layers got more numerous and more detached from underlying concepts and closer to "magic". <br/>
<br/>
While magic is generally good, too much will make for more instability in a sense that it's harder and harder to understand how things work. And because magic has its limits, swiftly come exceptions. As in, if magic doesn't work, here's a direct pathway 10 layers of abstraction down to how things really work, sort of like an oil rig deep into Earth that shows you where gas comes from, or visiting a farm to realize that not all good things grow on trees. That doesn't mean you need to drill your own oil rig or grow your own food of course. Some magic is still good. <br/>
<br/>
In terms of software development, the side effects of too much magic are brain freeze due to too much abstraction, performance issues, difficultly separating application layers (i.e. mixing it all together like flour and salt nearly impossible to separate again), difficulty debugging and overall acquiring sort of a tunnel vision that turns any given abstraction methodology into a hammer, and the whole world is one giant nail.<br/>
<div class="vsub"><a id="Spinning yarn"></a>Spinning yarn</div>
Regardless of how you feel about too much abstraction, programming languages tend to favor primitives that, when combined in a clever manner, yield higher-level function, until ultimately such function becomes business or consumer friendly. The process has been this way for over 50 years. Despite a plethora of languages out there, nothing has changed much. The basic blocks of languages remain primitives, and the building of applications from ground up remains the norm, rarely directly, and more by means of libraries building functionality on top of libraries.<br/>
<br/>
The reason for how all this developed in this manner (and why) would be a good topic for a study, and not just of programming languages but indeed first and foremost of human nature and the nature of business. On one hand, the original languages evolved in a relatively simple way with the rise of LALR and LR grammar tools, which made building a parser to be a streamlined process. It's a benefit, but also a trap, in a sense that it pigeon-holes the design of a language. Regardless of which parsing tools are used, it's the conceptually the same ball of yarn. This has resulted in a rather large number of languages that are in their basic nature clones of each other.<br/>
<div class="vsub"><a id="Specific purpose"></a>Specific purpose</div>
While the above applies to many languages, the situation isn't like that in some DSL (Domain-Specific Languages). Take for example SQL, or Structured Query Language. It's withstood the test of time with relatively minor changes, and even those that weren't minor came out well enough. Successful DSLs have something that general-purpose languages don't: firstly the power to cross the chasms of building functionality in very little code, and secondly the ease of use later in the development cycle, long after the dust settles. The former refers to typing a single (or very few) statements that take hundreds in other languages. The latter to being able to understand the code years later, or by other people.<br/>
<div class="vsub"><a id="Where does this lead"></a>Where does this lead</div>
Perhaps now is a good time to make a point. It's simple really; RimStone intends to:<br/>
<ul><li>reduce abstraction to specific tasks and concepts that are commonly used and understood, and nothing more,<br/>
</li><li>converge a general purpose language concept with a Domain-Specific one.</li></ul>
Or in a nutshell: a language that's naturally simple and general-purpose but with the two aforementioned benefits of DSLs. The process isn't straightforward because it's not just about grammars and BNF notations, or about pure structure. It's about the interaction between the language and a human. It's about reducing the effect of overly-expressioned and over-abstracted languages and escaping the trap of cookie-cutter churning of languages.<br/>
<br/>
Aside from grabbing the benefits of both, there's an additional, emerging one: some things that were "either/or" can now be together at the same time. I am talking about performance. Memory-safety can have a drawback: building "libraries on top of libraries" (or similar, as a method of building up functionality) carries a performance stick: there's a growing performance penalty because the cost of memory safety on every level of development starts to pile up. <br/>
<br/>
But if a programming language builds a large number of significant functionalities in just a single or few statements (such as in DSLs), then such functionalities can be built in C, which is the most energy-efficient and fastest programming language, according to <a href='https://www.sciencedirect.com/science/article/pii/S0167642321000022'>this study</a> (and also something that most of us intuitively understand). Building so can be done to include memory safety from the get-go with a much lower impact, and offers lots of customizations at the same time, yet still remain high-performance because it's built entirely in C. And the range of functionalities can be large, including databases, web technologies, distributed computing, regex, encryption, strings, files, parsing etc. It can include enough to be useful for building business and consumer applications.<br/>
<br/>
What this implies is that a hybrid between a general-purpose and a Domain-Specific language can be simple, memory safe and have high-performance, at the same time. It would emphasize near-expressionless statements that are close to natural way of thinking, instead of one based on over-abstraction and mechanical-parsing methods that's easier for a computer. RimStone is a hybrid language of that nature. One more benefit is that you may not need AI to summarize what the program does. If a single statement can convey a high-level intent, then you can read a program in such language more as a story of the solution than an algorithm.<br/>
<!--ENDVDOC90-->
<br/><div style='width:100%;clear:both;'>
<hr/>
<!--RIMFOOT77--><span style='font-size:80%'><a href="https://rimstone-lang.com/copyright.html">Copyright</a> (c) 2019-2025 Gliim LLC. All contents on this web site is "AS IS" without warranties or guarantees of any kind.</span>
</div><br/></body></html>


